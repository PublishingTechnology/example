/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. com\ingenta\search\parse\SearchExpressionParser.jj */
/*@egen*//* parsing search expressions */
/*c:\javacc-4.1\bin\javacc -LOOKAHEAD:2147483647 -debug_parser -force_la_check:true -output_directory:.\com\ingenta\search\setest SearchExpressionParser.jj


javac -classpath c:\javacc-4.1\bin\lib\javacc.jar com\ingenta\search\setest\*.java

java -cp . com.ingenta.search.SearchExpParser "\"ECONOMIC CRISIS\" OR (canada OR (shale NOT \"oil field\"))"
*/
options {
STATIC = false;
             

}
PARSER_BEGIN(SearchExpressionParser)

package com.ingenta.search.parse;

import java.io.*;
import java.util.List;

import com.ingenta.search.domain.SearchTerm;

public class SearchExpressionParser/*@bgen(jjtree)*/implements SearchExpressionParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSearchExpressionParserState jjtree = new JJTSearchExpressionParserState();

/*@egen*/

public SearchExpressionParser(String s) {

	this((Reader)(new StringReader(new String(s.getBytes(),"UTF-8"))));
}

public static void main( String[] args ){
	Node root = null;
        try
        {
              String query = args[0];
              query = query.replaceAll("\\)", " \\) ").replaceAll("\\(", " \\( ").replaceAll("[ ]+", " ").replaceAll(" $", "");
              SearchExpressionParser parser = new SearchExpressionParser(query + " \n");
              ASTinput e = parser.input();
              e.dump(">");
              root = parser.jjtree.rootNode();
              root.interpret();              
        }
        catch(Exception e)
        {
              e.printStackTrace();
        }
    }
    
public List<SearchTerm> parseSearchTerms() throws ParseException{
	
	List<SearchTerm> list = null;
		ASTinput e = this.input();
		Node root = this.jjtree.rootNode();
		list = ((SimpleNode)root).getSearchTermList();	
	return list;
	
}
    
    
}

PARSER_END(SearchExpressionParser)


SPECIAL_TOKEN : { " " }
TOKEN :{ < EF : ["\n","\r"] > }
TOKEN : { < OR : "OR" > }
TOKEN : { < AND : "AND" | "UND"> }
TOKEN : { < NOT : "NOT" | "NICHT"> }
TOKEN : { < LPAR : "(" > }
TOKEN : { < RPAR : ")" > }
TOKEN : { < STRING : (["!","#"-"&","*"-"\uffff"])+ > } 
TOKEN : { < PHRASE1 : "\"" (~["\""])+ "\"" > }
TOKEN : { < PHRASE2 : "'" (~["'"])+ "'" > }


ASTinput input() :
{/*@bgen(jjtree) input */
  ASTinput jjtn000 = new ASTinput(JJTINPUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) input */
try {
/*@egen*/
(stringorphraseorgroup())*
<EF>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


void group() :
{/*@bgen(jjtree) group */
  ASTgroup jjtn000 = new ASTgroup(JJTGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) group */
try {
/*@egen*/

<LPAR> (stringorphraseorgroup())* <RPAR>
|
<LPAR> stringorphraseorgroup() (operator() stringorphraseorgroup())* <RPAR>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}



void stringorphraseorgroup() :
{/*@bgen(jjtree) stringorphraseorgroup */
  ASTstringorphraseorgroup jjtn000 = new ASTstringorphraseorgroup(JJTSTRINGORPHRASEORGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) stringorphraseorgroup */
try {
/*@egen*/
stringorphrase() (operator() stringorphraseorgroup())*
|
group() (operator() stringorphraseorgroup())*
|
stringorphrase()
|
group()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

void stringorphrase() : 
{/*@bgen(jjtree) stringorphrase */
ASTstringorphrase jjtn000 = new ASTstringorphrase(JJTSTRINGORPHRASE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
}
{/*@bgen(jjtree) stringorphrase */
try {
/*@egen*/
(
t=<STRING>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{ 
	try{
		jjtn000.val = new String(t.image.trim().getBytes(),"UTF-8");
	}
	catch(Exception e){
		
	}
} 
| 
t=<PHRASE1>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{ 
	try{
		jjtn000.val = new String(t.image.trim().getBytes(),"UTF-8");
	}
	catch(Exception e){
		
	}
} 
| 
t=<PHRASE2>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{ 
	try{
		jjtn000.val = new String(t.image.trim().getBytes(),"UTF-8");
	}
	catch(Exception e){
		
	}
} 


)/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


void operator() :
{/*@bgen(jjtree) operator */
ASToperator jjtn000 = new ASToperator(JJTOPERATOR);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
}
{/*@bgen(jjtree) operator */
try {
/*@egen*/
(
t=<AND>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {jjtn000.val = t.image.trim();} 
|
t=<NOT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {jjtn000.val = t.image.trim();}
| 
t=<OR>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/ {jjtn000.val = t.image.trim();}
)/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}